/********************************************************
[Pointer]
 - 포인터는 주소를 저장하는 변수
 - 기존의 변수는 데이터를 저장하는데 반하여 포인터는 메모리 공간의 주소를 저장.
 - 포인터 변수가 주소를 저장하려면 변수의 주소를 알아야한다.
 - 변수 이름 앞에 & 연산자를 붙이면 해당 변수의 시작주소를 반환한다.
 - 또한 포인터 변수가 저장하는 변수의 주소에 저장된 값을 참조하려면 * 연산자를 이용한다.(역참조)

 [포인터 연산자]
 & : 특정한 데이터의 메모리 상의 주소값을 알 수 있다.
 * : & 연산자가 어떠한 데이터의 주소값을 얻어내는 연산자라면
	 거꾸로 주소값에서 해당 주소값에 해당되는 데이터를 가져오는 연산자가 필요할 때 사용


 [포인터 정의방법]
 (포인터에 주소값이 저장되는 데이터형)* 포인터의 이름

********************************************************/

/*
 ??포인터에는 왜 타입이 있을까?
 어차피 주소만 저장하다메...?

 만약에 포인터라는 타입이 있다면?
 int a;
 Pointer(라는 타입이 있다고 할 때)*p;
 p = &a;

 p는 a의 주소값이 저장되어있음.
 문제는 a가 메모리에서 차지하는 모든 주소들의 위치가 들어가 있는게 아니라...
 시작주소만 들어가 있다.

 즉, 컴퓨터가 메모리에 얼마만큼 읽어 들여야 할지 알 방법이 없다.


*/

#include<iostream>


int main()
{
	//우리가 알고 있는 변수
	//int a = 1;

	//int* p;

	//int a;
	//a = 2;
	//p = &a; //변수 a의 주소를 포인터 변수 p에 저장

	//std::cout << "p의 값 : " << p << std::endl;
	//std::cout << "변수 a의 주소 : " << &a << std::endl;

	//std::cout << "*p의 값(a에 저장된 데이터)" << *p << std::endl;
	//std::cout << "포인터 변수 p의 주소" << &p << std::endl;

	////역참조
	//*p = 555;
	//std::cout << "역참조 후 변수 a의 데이터 : " << a << std::endl;

	
	int num = 10;
	int* p = &num;

	int** pp;
	pp = &p;

	std::cout << "pp의 값 : (포인터 변수 p 의 주소값)" << pp << std::endl;

	**pp = 1234;
	std::cout << num << std::endl;

	//아무것도 가리키게 하지 않는다. 포인터 초기화
	//int* ptr = nullptr;

	int* ptr = new int(42); //동적 메모리 할당. ptr 메모리의 주소를 가리키고 있음


	std::cout << "동적 할당된 값 : " << *ptr << std::endl;
	std::cout << "ptr의 주소 : " << ptr << std::endl;

	delete ptr; //댕글링포인터. 이미 해제된 메모리 영역을 가리키고 있음

	std::cout << "해제 후 ptr의 주소 : " << ptr << std::endl;

	ptr = nullptr;
	std::cout << "널포인터로 안전하게 : " << ptr << std::endl;

	//스마트포인터 별도공부 필요, 면접질문 나올 수 있음.


}