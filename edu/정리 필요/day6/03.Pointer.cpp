/***************************************************************
포인터 배열
- 말 그대로 포인터들의 배열(배열의 각 요소가 포인터)
- 배열의 타입을 int, char 등등으로 하듯이 배열의 타입을 int* 으로 선언
- 즉, 배열의 각각의 원소는 int를 가리키는 포인터 형으로 선언
- 따라서 int 배열에서 각각의 원소를 int형 변수로 취급했던 것처럼
  int*배열에서 각각의 원소를 포인터로 취급할 수 있음.


***************************************************************/


//만약 배열을 받아서 두 숫자를 더하는 함수를 만든다면?
#include<iostream>

using namespace std;


int AddNum(int number[])
{
	return number[0] + number[1];
}
//두 배열을 받아서 각 인덱스의 값들을 더하는 함수는?

void AddArr(int arr1[], int arr2[], int s)
{
	for (int i = 0; i < s; i++)
	{
		cout << arr1[i] << " + " << arr2[i] << " = " << (arr1[i] + arr2[i]) << endl;
	}
}


int main()
{
	////포인터 배열
	//int* arr[3];

	//int num1 = 1;
	//int num2 = 2;
	//int num3 = 3;

	//arr[0] = &num1;
	//arr[1] = &num2;
	//arr[2] = &num3;

	//cout << "num1 : " << num1 << " , *arr[0]" << *arr[0] << endl;
	//cout << "num2 : " << num2 << " , *arr[1]" << *arr[1] << endl;
	//cout << "num3 : " << num3 << " , *arr[2]" << *arr[2] << endl;

	//cout << &num1 << "   " << arr[0] << endl;

	//////////////////////////////////////////////////////////////
	//cout << endl << endl;
	///*
	// 배열 포인터
	// - 배열의 첫번째 요소를 가리키는 포인터
	// - 배열의 이름은 배열의 첫번째 요소의 주소 이므로 배열 포인터를 사용하면 배열 요소에 쉽게 접근이 가능하다.
	// 
	// 
	// [배열의 이름과 첫번째 원소와의 관계]
	// - 배열의 이름은 첫번째 원소를 가리키는 포인터라고 할 수 있냐?
	// - 배열의 이름은 첫번째 원소와 주소와 같지만 배열의 이름 자체는 포인터가 아님.
	// - 배열은 배열자체의 데이터 구조이고 포인터는 메모리 주소를 가리키기 떄문
	// - 배열의 이름을 사용할 때, 암묵적으로 배열의 첫번째 원소를 가리키는 포인터로 타입 변환됨.
	// - 즉, 배열의 이름을 포인터처럼 사용할 수 있지만 다른 개념.
	// */

	//int arr1[10] = { 1,2,3,4,5,6,7,8,9,10 };
	//int* pArr; //
	//pArr = arr1; //배열의 시작주소를 저장

	//for (int i = 0; i < 10; i++)
	//{
	//	cout << "arr1[" << i << "]의 주소값 : " << &arr1[i] << "";
	//	cout << "(pArr+" << i << ")의 값 |" << (pArr + i) << "";


	//		if (&arr1[i] == (pArr + i))
	//		{
	//			cout << "----> 일치" << endl;
	//		}
	//		else
	//		{
	//			cout << "불일치" << endl;
	//		}
	//}


	/////////////////////////////////////////////////////////////////////////
	///*
	//상수 포인터
	// - 상수 포인터는 두가지 방식으로 사용.
	// 1. 포인터 자체가 상수인 경우
	//  - 포인터가 가리키는 변경할 수 없지만, 그 주소에 저장된 값은 변경 가능
	// 2. 포인터가 가리키는 값이 상수인 경우
	//  - 포인터가 가리키는 값을 변경할 수 없지만, 포인터 자체는 다른 주소를 가리킬 수 있다.
	//*/
	////포인터 상수
	//int num = 10;
	//int* const ptr = &num;
	//*ptr = 30;

	//cout << *ptr << endl; //가능(ptr이 가리키는 값 변경)
	//int otherNum = 5;
	////ptr = &otherNum; //불가능(ptr이 다른 주소를 가리키게 할 수 없음)


	////상수 포인터
	//int val = 10;
	//const int* ptr1 = &val;

	//int otherNum1 = 5;

	////*ptr1 = 20; //불가능
	//ptr1 = &otherNum1; //가능
	
	int num[] = { 1,2 };

	int res = AddNum(num);
	cout << res << endl;

	const int size = 3;
	int numArr1[size] = { 1,2,3 };
	int numArr2[size] = { 4,5,6 };

	AddArr(numArr1, numArr2, size);

}

/*
[주말과제]

트럼프카드 52장
다이아	 A ~ K
하트		 A ~ K
클로버	 A ~ K
스페이드	 A ~ K

1. 트럼프 카드는 위와 같이 52장이 있다.
2. 플레이어가 있다.
3. 딜러가 있다.

게임조건
- 딜러는 3장의 카드를 보여준다.
 하트A(1), 다이아7, 클로버8(치트키)
- 플레이어는 베팅을 한다.
- 이기는 조건은...(배팅한 금액의 *2)
 ㄴ첫번째 카드와 두번째 카드 사이에 세번째 카드가
 ㄴ범위 안에 있다. 그러면 이김.
 ㄴ예시의 경우는 짐
- 같은 카드는 또 나오면 안됨.
- 특정 확률로 잭팟

종료조건
- 당연히 어제와 같은 조건일 것 같고..
 ㄴ소지금 0 또는 17판



 




*/